//###########################################################################
// This file is part of LImA, a Library for Image Acquisition
//
// Copyright (C) : 2009-2011
// European Synchrotron Radiation Facility
// BP 220, Grenoble 38043
// FRANCE
//
// This is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//###########################################################################
%Module(name=limacore)

%Platforms {WIN32_PLATFORM WIN64_PLATFORM POSIX_PLATFORM}

%Feature WITH_CONFIG
%Feature WITH_SPS_IMAGE

// Note: NumPy C-API is used by Lima binding. The header files
// defining the NumPy C-API are only intepreted the first time they
// are included in the compilation unit. In particular, the header
// "npy_3kcompat.h" also includes the C-API. The macros NO_IMPORT[_ARRAY]
// and PY_ARRAY_UNIQUE_SYMBOL modify the behaviour of the header files
// and must be defined before those files are interpreted. The C-API
// can be imported only once per each module.
//
// SIP can be configured to create one or multiple compilation units,
// either one per mapped type plus one for the Python module, or an
// arbitrary number, for parallelisation. In order to have deterministic
// behaviour, all the compilation units generated by SIP define
// NO_IMPORT_ARRAY and, if Python 3, include the "npy_3kcompat.h" header.
// NumPy C-API is imported and initialised by "limacore_import_array"
// in a separate "lima_init_numpy.cpp" file, called from the
// "limacore" module (post)initisation

%ModuleHeaderCode
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL _@PROJECT_NAME@NumpyArray
#include "numpy/arrayobject.h"
#if (defined(NPY_API_VERSION) && NPY_API_VERSION >= 0x00000004 && PY_VERSION_HEX >= 0x03000000)
#include "numpy/npy_3kcompat.h"
#endif

extern "C"
{
#if PY_VERSION_HEX >= 0x03000000
int @PROJECT_NAME_LOWER@_import_array();
#else
void @PROJECT_NAME_LOWER@_import_array();
#endif
}
%End

%ModuleHeaderCode
#include "lima/SoftOpId.h"

inline PyObject *sipConvertToPyStr(const std::string& s)
{
    PyObject *newstring;

#if PY_MAJOR_VERSION >= 3
    // convert an std::string to a Python (unicode) string
    newstring = PyUnicode_DecodeUTF8(s.c_str(), s.length(), NULL);
    if (newstring == NULL) {
        PyErr_Clear();
        newstring = PyString_FromString(s.c_str());
    }
#else
    // convert an std::string to a Python string - assume an ASCII string
    newstring = PyString_FromString(s.c_str());
#endif

  return newstring;
}

inline bool sipCheckConvertFromPyStr(PyObject *sipPy)
{
    return (PyString_Check(sipPy) || PyUnicode_Check(sipPy));
}

inline std::string sipConvertFromPyStr(PyObject *sipPy)
{
    std::string s;
    // Allow a Python string (or a unicode string) whenever a string is
    // expected.
    // If argument is a Unicode string, just decode it to UTF-8
    // If argument is a Python string, assume it's UTF-8
    if (PyUnicode_Check(sipPy)) {
        PyObject *pyS = PyUnicode_AsEncodedString(sipPy, "UTF-8", "");
        s = PyString_AS_STRING(pyS);
        Py_DECREF(pyS);
    } else if (PyString_Check(sipPy)) {
        s = PyString_AS_STRING(sipPy);
    } else if (sipPy != Py_None) {
        throw std::exception();
    }
    return s;
}
%End

// Creates the mapping for std::string
// From: http://www.riverbankcomputing.com/pipermail/pyqt/2009-July/023533.html

%MappedType std::string
{
%TypeHeaderCode
#include <string>
%End

%ConvertFromTypeCode
  return sipConvertToPyStr(*sipCpp);
%End

%ConvertToTypeCode
    if (sipIsErr == NULL)
        return sipCheckConvertFromPyStr(sipPy);

    try {
    	 *sipCppPtr = new std::string(sipConvertFromPyStr(sipPy));
    } catch (...) {
         return 0;
    }
    return 1;
%End
};

%MappedType std::vector<std::string>
{
%TypeHeaderCode
#include <string>
#include <vector>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
{
  bool aReturnFlag = PyList_Check(sipPy);
  for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
	  aReturnFlag = sipCheckConvertFromPyStr(PyList_GET_ITEM(sipPy,i));
  return aReturnFlag;
}

*sipCppPtr = new std::vector<std::string>(PyList_Size(sipPy));
for(int i = 0;i < PyList_Size(sipPy);++i)
{
  PyObject *aPyObj = PyList_GET_ITEM(sipPy, i);
  if (aPyObj != Py_None)
    (**sipCppPtr)[i] = sipConvertFromPyStr(aPyObj);
}
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
// convert an std::vector<std::string> to a Python (unicode) string list
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::vector<std::string>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i) {
  PyObject *newstring = sipConvertToPyStr(*vIter);
  PyList_SET_ITEM(aReturnListPt,i,newstring);
}

return aReturnListPt;
%End

};

%MappedType std::vector<int>
{
%TypeHeaderCode
#include <vector>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
	aReturnFlag = PyInt_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::vector<int>(PyList_Size(sipPy));
for(int i = 0;i < PyList_Size(sipPy);++i)
  (*sipCppPtr)->operator[](i) = PyInt_AS_LONG(PyList_GET_ITEM(sipPy,i));

    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::vector<int>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i)
  PyList_SET_ITEM(aReturnListPt,i,PyInt_FromLong(*vIter));

return aReturnListPt;
%End

};

%MappedType std::vector<long>
{
%TypeHeaderCode
#include <vector>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
        aReturnFlag = PyInt_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::vector<long>(PyList_Size(sipPy));
for(int i = 0;i < PyList_Size(sipPy);++i)
  (*sipCppPtr)->operator[](i) = PyInt_AS_LONG(PyList_GET_ITEM(sipPy,i));

    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::vector<long>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i)
  PyList_SET_ITEM(aReturnListPt,i,PyInt_FromLong(*vIter));

return aReturnListPt;
%End

};

%MappedType std::vector<double>
{
%TypeHeaderCode
#include <vector>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
        aReturnFlag = PyFloat_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::vector<double>(PyList_Size(sipPy));
for(int i = 0;i < PyList_Size(sipPy);++i)
  (*sipCppPtr)->operator[](i) = PyFloat_AS_DOUBLE(PyList_GET_ITEM(sipPy,i));

    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::vector<double>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i)
  PyList_SET_ITEM(aReturnListPt,i,PyFloat_FromDouble(*vIter));

return aReturnListPt;
%End

};

%MappedType std::vector<float>
{
%TypeHeaderCode
#include <vector>
%End

%ConvertToTypeCode
if (sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
        aReturnFlag = PyFloat_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::vector<float>(PyList_Size(sipPy));
for(int i = 0;i < PyList_Size(sipPy);++i)
  (*sipCppPtr)->operator[](i) = PyFloat_AS_DOUBLE(PyList_GET_ITEM(sipPy,i));

    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::vector<float>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i)
  PyList_SET_ITEM(aReturnListPt,i,PyFloat_FromDouble(*vIter));

return aReturnListPt;
%End

};

%MappedType std::list<double>
{
%TypeHeaderCode
#include <list>
%End

%ConvertToTypeCode
if(sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
	aReturnFlag = PyFloat_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::list<double>();
for(int i = 0;i < PyList_Size(sipPy);++i)
	(*sipCppPtr)->push_back(PyFloat_AS_DOUBLE(PyList_GET_ITEM(sipPy,i)));
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::list<double>::iterator lIter = sipCpp->begin();

for(int i = 0;lIter != sipCpp->end();++lIter,++i)
   PyList_SET_ITEM(aReturnListPt,i,PyFloat_FromDouble(*lIter));
return aReturnListPt;
%End
};

%MappedType std::list<int>
{
%TypeHeaderCode
#include <list>
%End

%ConvertToTypeCode
if(sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
	aReturnFlag = PyInt_Check(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::list<int>();
for(int i = 0;i < PyList_Size(sipPy);++i)
	(*sipCppPtr)->push_back(PyInt_AS_LONG(PyList_GET_ITEM(sipPy,i)));
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::list<int>::iterator lIter = sipCpp->begin();

for(int i = 0;lIter != sipCpp->end();++lIter,++i)
   PyList_SET_ITEM(aReturnListPt,i,PyInt_FromLong(*lIter));
return aReturnListPt;
%End
};

%MappedType std::map<int,std::string>
{
%TypeHeaderCode
#include <map>
#include <string>
%End

%ConvertToTypeCode
PyObject *key, *value;
SIP_SSIZE_T pos;

if(sipIsErr == NULL)
{
  bool aReturnFlag = PyDict_Check(sipPy);

  pos = 0;
  while(aReturnFlag && PyDict_Next(sipPy, &pos, &key, &value))
     aReturnFlag = PyInt_Check(key) && sipCheckConvertFromPyStr(value);

  return aReturnFlag;
}

*sipCppPtr = new std::map<int,std::string>();
pos = 0;
while(PyDict_Next(sipPy, &pos, &key, &value))
{
  int anIndex = PyInt_AS_LONG(key);
  std::pair<int,std::string> item(anIndex, sipConvertFromPyStr(value));
  (*sipCppPtr)->insert(item);
}
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnDictPt = PyDict_New();

std::map<int,std::string>::iterator mIter, mEnd = sipCpp->end();
for(mIter = sipCpp->begin(); mIter != mEnd; ++mIter)
   {
    PyObject *aKeyPt = PyInt_FromLong(mIter->first);
    PyObject *aValuePt = sipConvertToPyStr(mIter->second);
    PyDict_SetItem(aReturnDictPt,aKeyPt,aValuePt);
    Py_DECREF(aKeyPt);Py_DECREF(aValuePt);
   }
return aReturnDictPt;
%End
};

%MappedType std::map<int,std::list<std::string>>
{
%TypeHeaderCode
#include <map>
#include <list>
#include <string>
%End

%ConvertToTypeCode
PyObject *key, *value;
SIP_SSIZE_T pos;

if(sipIsErr == NULL)
{
  bool aReturnFlag = PyDict_Check(sipPy);

  pos = 0;
  while(aReturnFlag && PyDict_Next(sipPy, &pos, &key, &value))
   {
     aReturnFlag = PyInt_Check(key) && PyList_Check(value);
     for(int i = 0;aReturnFlag && i < PyList_Size(value);++i)
	aReturnFlag = sipCheckConvertFromPyStr(PyList_GET_ITEM(value,i));
   }
  return aReturnFlag;
}

*sipCppPtr = new std::map<int,std::list<std::string> >();
pos = 0;
while(PyDict_Next(sipPy, &pos, &key, &value))
{
  int anIndex = PyInt_AS_LONG(key);
  std::pair<std::map<int,std::list<std::string> >::iterator, bool> aResult =
  (*sipCppPtr)->insert(std::pair<int,std::list<std::string> >(anIndex,std::list<std::string>()));

  for(int i = 0;i < PyList_Size(value);++i)
  {
    PyObject *aPyObj = PyList_GET_ITEM(value, i);
    if (aPyObj != Py_None)
      aResult.first->second.push_back(sipConvertFromPyStr(aPyObj));
  }
}
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnDictPt = PyDict_New();


for(std::map<int,std::list<std::string> >::iterator mIter = sipCpp->begin();
    mIter != sipCpp->end();++mIter)
   {
    PyObject *aKeyPt = PyInt_FromLong(mIter->first);
    PyObject *aValuePt = PyList_New(mIter->second.size());
    PyDict_SetItem(aReturnDictPt,aKeyPt,aValuePt);
    Py_DECREF(aKeyPt);Py_DECREF(aValuePt);
    std::list<std::string>::iterator sPt = mIter->second.begin();
    for(int i = 0;sPt != mIter->second.end();++i,++sPt) {
      PyObject *newstring = sipConvertToPyStr(*sPt);
      PyList_SET_ITEM(aValuePt,i,newstring);
    }
   }
return aReturnDictPt;
%End
};

%MappedType std::list<std::string>
{
%TypeHeaderCode
#include <list>
#include <string>
%End

%ConvertToTypeCode
if(sipIsErr == NULL)
{
bool aReturnFlag = PyList_Check(sipPy);
for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
  aReturnFlag = sipCheckConvertFromPyStr(PyList_GET_ITEM(sipPy,i));
return aReturnFlag;
}

*sipCppPtr = new std::list<std::string>();
for(int i = 0;i < PyList_Size(sipPy);++i)
{
  PyObject *aPyObj = PyList_GET_ITEM(sipPy, i);
  if (aPyObj != Py_None)
    (*sipCppPtr)->push_back(sipConvertFromPyStr(aPyObj));
}
return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::list<std::string>::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i) {
    PyObject *newstring = sipConvertToPyStr(*vIter);
    PyList_SET_ITEM(aReturnListPt,i,newstring);
}
return aReturnListPt;
%End

};

%MappedType std::list<std::list<long long>>
{
%TypeHeaderCode
#include <list>
%End

%ConvertToTypeCode
if(sipIsErr == NULL)
{
  bool aReturnFlag = PyList_Check(sipPy);
  for(int i = 0;aReturnFlag && i < PyList_Size(sipPy);++i)
  {
    PyObject *listPt = PyList_GET_ITEM(sipPy,i);
    aReturnFlag = PyList_Check(listPt);
    for(int j = 0;aReturnFlag && j < PyList_Size(listPt);++j)
      aReturnFlag = PyInt_Check(PyList_GET_ITEM(listPt,j));
  }
  return aReturnFlag;
}


*sipCppPtr = new std::list<std::list<long long> >();
for(int i = 0;i < PyList_Size(sipPy);++i)
{
  PyObject *listPt = PyList_GET_ITEM(sipPy,i);
  (*sipCppPtr)->push_back(std::list<long long>());
  std::list<long long> &aList = (*sipCppPtr)->back();
  for(int j = 0;j <  PyList_Size(listPt);++j)
    aList.push_back(PyInt_AS_LONG(PyList_GET_ITEM(listPt,j)));
}

return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
PyObject* aReturnListPt = PyList_New(sipCpp->size());
std::list<std::list<long long> >::iterator vIter = sipCpp->begin();

for(int i = 0;vIter != sipCpp->end();++vIter,++i)
{
   std::list<long long> &aList = *vIter;
   PyObject* aListPyPt = PyList_New(aList.size());
   PyList_SET_ITEM(aReturnListPt,i,aListPyPt);
   std::list<long long>::iterator sIter = aList.begin();
   for(int j = 0;sIter != aList.end();++sIter,++j)
     PyList_SET_ITEM(aListPyPt,j,PyInt_FromLong(*sIter));
}
return aReturnListPt;
%End
};

%UnitCode

#if !defined(LIMA_REPR_CODE)
#define LIMA_REPR_CODE \
  std::ostringstream str; \
  str << *sipCpp;	\
  sipRes = sipConvertToPyStr(str.str());
#endif // !defined(LIMA_REPR_CODE)

#ifdef _DEBUG
# ifdef _MSC_VER  
   // VC8.0 will complain if system headers are #included both with
   // and without _DEBUG defined, so we have to #include all the
   // system headers used by pyconfig.h right here.
#  include <stddef.h>
#  include <stdarg.h>
#  include <stdio.h>
#  include <stdlib.h>
#  include <assert.h>
#  include <errno.h>
#  include <ctype.h>
#  include <wchar.h>
#  include <basetsd.h>
#  include <io.h>
#  include <limits.h>
#  include <float.h>
#  include <string.h>
#  include <math.h>
#  include <time.h>
# endif
# undef _DEBUG // Don't let Python force the debug library just because we're debugging.
# define DEBUG_WRAP_PYTHON_H
#endif

#include <Python.h>

#ifdef DEBUG_WRAP_PYTHON_H
# define _DEBUG
#endif

%End

%PostInitialisationCode
@PROJECT_NAME_LOWER@_import_array();
%End

%Import processlib.sip

@INCLUDES@
