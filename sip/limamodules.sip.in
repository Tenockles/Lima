%Module(name=@MODULE_NAME@)

// Note: NumPy C-API is used by Lima binding. The header files
// defining the NumPy C-API are only intepreted the first time they
// are included in the compilation unit. In particular, the header
// "npy_3kcompat.h" also includes the C-API. The macros NO_IMPORT[_ARRAY]
// and PY_ARRAY_UNIQUE_SYMBOL modify the behaviour of the header files
// and must be defined before those files are interpreted. The C-API
// can be imported only once per each module.
//
// SIP can be configured to create one or multiple compilation units,
// either one per mapped type plus one for the Python module, or an
// arbitrary number, for parallelisation. In order to have deterministic
// behaviour, all the compilation units generated by SIP define
// NO_IMPORT_ARRAY and, if Python 3, include the "npy_3kcompat.h" header.
// NumPy C-API is imported and initialised by "@MODULE_NAME@_import_array"
// in a separate "@MODULE_NAME@_init_numpy.cpp" file, called from the
// "@MODULE_NAME@" module (post)initisation

%ModuleHeaderCode
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL _@PROJECT_NAME@NumpyArray
#include "numpy/arrayobject.h"
#if (defined(NPY_API_VERSION) && NPY_API_VERSION >= 0x00000004 && PY_VERSION_HEX >= 0x03000000)
#include "numpy/npy_3kcompat.h"
#endif

extern "C" {
#if PY_VERSION_HEX >= 0x03000000
int @PROJECT_NAME_LOWER@_import_array();
#else
void @PROJECT_NAME_LOWER@_import_array();
#endif
}
%End

%ModuleHeaderCode
#include "lima/SoftOpId.h"

inline PyObject *sipConvertToPyStr(const std::string& s)
{
    PyObject *newstring;

#if PY_MAJOR_VERSION >= 3
    // convert an std::string to a Python (unicode) string
    newstring = PyUnicode_DecodeUTF8(s.c_str(), s.length(), NULL);
    if (newstring == NULL) {
        PyErr_Clear();
        newstring = PyString_FromString(s.c_str());
    }
#else
    // convert an std::string to a Python string - assume an ASCII string
    newstring = PyString_FromString(s.c_str());
#endif

  return newstring;
}

inline bool sipCheckConvertFromPyStr(PyObject *sipPy)
{
    return (PyString_Check(sipPy) || PyUnicode_Check(sipPy));
}

inline std::string sipConvertFromPyStr(PyObject *sipPy)
{
    std::string s;
    // Allow a Python string (or a unicode string) whenever a string is
    // expected.
    // If argument is a Unicode string, just decode it to UTF-8
    // If argument is a Python string, assume it's UTF-8
    if (PyUnicode_Check(sipPy)) {
        PyObject *pyS = PyUnicode_AsEncodedString(sipPy, "UTF-8", "");
        s = PyString_AS_STRING(pyS);
        Py_DECREF(pyS);
    } else if (PyString_Check(sipPy)) {
        s = PyString_AS_STRING(sipPy);
    } else if (sipPy != Py_None) {
        throw std::exception();
    }
    return s;
}
%End

%UnitCode

#if !defined(LIMA_REPR_CODE)
#define LIMA_REPR_CODE \
  std::ostringstream str; \
  str << *sipCpp;	\
  sipRes = sipConvertToPyStr(str.str());
#endif // !defined(LIMA_REPR_CODE)

#ifdef _DEBUG
# ifdef _MSC_VER  
   // VC8.0 will complain if system headers are #included both with
   // and without _DEBUG defined, so we have to #include all the
   // system headers used by pyconfig.h right here.
#  include <stddef.h>
#  include <stdarg.h>
#  include <stdio.h>
#  include <stdlib.h>
#  include <assert.h>
#  include <errno.h>
#  include <ctype.h>
#  include <wchar.h>
#  include <basetsd.h>
#  include <io.h>
#  include <limits.h>
#  include <float.h>
#  include <string.h>
#  include <math.h>
#  include <time.h>
# endif
# undef _DEBUG // Don't let Python force the debug library just because we're debugging.
# define DEBUG_WRAP_PYTHON_H
#endif

#include <Python.h>

#ifdef DEBUG_WRAP_PYTHON_H
# define _DEBUG
#endif

%End

%PostInitialisationCode
@PROJECT_NAME_LOWER@_import_array();
%End

@IMPORTS@

@INCLUDES@

%ModuleHeaderCode
#include "lima/Exceptions.h"
static inline void LimaExceptionTest()
{
	throw LIMA_HW_EXC(lima::Error, "Test exception");
}
%End

void LimaExceptionTest() throw (Exception);
